Â«x:# ==============================Â»
Â«x:# tuple collectionsÂ»
Â«x:# ==============================Â»

()
Â«x:# There's no (,)Â»

(Â«c:1Â») Â«x:# NOT a tupleÂ»
(Â«c:1Â»,)
(Â«c:2Â»,Â«c:3Â»,Â«c:4Â»,)

Â«x:# ==============================Â»
Â«x:# named tuple collectionsÂ»
Â«x:# ==============================Â»

(Â«v:aÂ» = Â«c:1Â») Â«x:# NOT a tupleÂ»
(a = Â«c:1Â»,)
(a = Â«c:1Â», b = Â«c:2Â»)
(;)
(; a)
(; a = Â«c:1Â»)
(; a = Â«c:1Â», b = Â«c:2Â»)
(; a, foo.b)

Â«x:# ==============================Â»
Â«x:# vector array collectionsÂ»
Â«x:# ==============================Â»

[]
Â«x:# There's no [,]Â»
[x]
[x,]
[Â«c:1Â», Â«c:2Â»]

Â«x:# Check unary-and-binary-operatorsÂ»
[x.-y, Â«c:2Â»]

Â«x:# ==============================Â»
Â«x:# matrix array collectionsÂ»
Â«x:# ==============================Â»

[x;]
[Â«c:1Â» Â«c:2Â»]
[Â«c:1Â» Â«c:2Â»; Â«c:3Â» Â«c:4Â»]
[Â«c:1Â» Â«c:2Â»
 Â«c:3Â» Â«c:4Â»]
[Â«c:1Â»
 Â«c:2Â»
 Â«c:3Â»
]
[
 a;
 b;
 c;
]
[Â«c:1Â»;; Â«c:2Â»;; Â«c:3Â»;;; Â«c:4Â»;; Â«c:5Â»;; Â«c:6Â»;;]
Int[Â«c:1Â» Â«c:2Â» Â«c:3Â» Â«c:4Â»]

Â«x:# ========================================Â»
Â«x:# comprehension array collectionsÂ»
Â«x:# ========================================Â»

[x Â«k:forÂ» x Â«k:inÂ» xs]
[x
  Â«k:forÂ» x Â«k:inÂ» xs
  Â«k:ifÂ» x > Â«c:0Â»
]
UInt[b(c, e) Â«k:forÂ» c Â«k:inÂ» d Â«k:forÂ» e Â«k:inÂ» f]

f(Â«c:1Â», Â«c:2Â», i Â«k:forÂ» i Â«k:inÂ» iter)
(b(c, e) Â«k:forÂ» c Â«k:inÂ» d, e = Â«c:5Â» Â«k:ifÂ» e)

Â«x:# ==============================Â»
Â«x:# module definitionsÂ»
Â«x:# ==============================Â»

Â«k:moduleÂ» A

Â«k:baremoduleÂ» B Â«k:endÂ»

Â«k:moduleÂ» C
Â«k:endÂ»

Â«k:endÂ»

Â«x:# ==============================Â»
Â«x:# abstract type definitionsÂ»
Â«x:# ==============================Â»

Â«k:abstractÂ» Â«k:typeÂ» Â«t:TÂ» Â«k:endÂ»
Â«k:abstractÂ» Â«k:typeÂ» Â«t:TÂ» <: Â«t:SÂ» Â«k:endÂ»
Â«k:abstractÂ» Â«k:typeÂ» Â«t:TÂ»{Â«t:SÂ»} <: Â«t:UÂ» Â«k:endÂ»

Â«x:# ==============================Â»
Â«x:# primitive type definitionsÂ»
Â«x:# ==============================Â»

Â«k:primitiveÂ» Â«k:typeÂ» Â«t:TÂ» Â«c:8Â» Â«k:endÂ»
Â«k:primitiveÂ» Â«k:typeÂ» Â«t:TÂ» <: Â«t:SÂ» Â«c:16Â» Â«k:endÂ»
Â«k:primitiveÂ» Â«k:typeÂ» Â«t:PtrÂ»{Â«t:TÂ»} Â«c:32Â» Â«k:endÂ»

Â«x:# ==============================Â»
Â«x:# struct definitionsÂ»
Â«x:# ==============================Â»

Â«k:structÂ» Â«t:UnitÂ» Â«k:endÂ»

Â«k:structÂ» Â«t:MyIntÂ» field::Â«t:IntÂ» Â«k:endÂ»

Â«k:mutableÂ» Â«k:structÂ» Â«t:FooÂ»
  bar
  baz::Â«t:Float64Â»
Â«k:endÂ»

Â«x:# ==============================Â»
Â«x:# parametric struct definitionsÂ»
Â«x:# ==============================Â»

Â«k:structÂ» Â«t:PointÂ»{Â«t:TÂ»}
  x::Â«t:TÂ»
  y::Â«t:TÂ»
Â«k:endÂ»

Â«k:structÂ» Â«t:RationalÂ»{Â«t:TÂ»<:Â«t:IntegerÂ»} <: Â«t:RealÂ»
  num::Â«t:TÂ»
  den::Â«t:TÂ»
Â«k:endÂ»

Â«k:mutableÂ» Â«k:structÂ» Â«t:MyVecÂ» <: Â«t:AbstractArrayÂ»
  foos::Â«t:VectorÂ»{Â«t:FooÂ»}
Â«k:endÂ»

Â«x:# ==============================Â»
Â«x:# function definitionsÂ»
Â«x:# ==============================Â»

Â«k:functionÂ» Â«f:fÂ» Â«k:endÂ»

Â«k:functionÂ» Â«f:nopÂ»() Â«k:endÂ»

Â«k:functionÂ» Â«f:IÂ»(x) x Â«k:endÂ»

Â«k:functionÂ» Base.Â«f:randÂ»(n::Â«t:MyIntÂ»)
    Â«k:returnÂ» Â«c:4Â»
Â«k:endÂ»

Â«k:functionÂ» Â«f:Î“Â»(z)
    gamma(z)
Â«k:endÂ»

Â«k:functionÂ» Â«f:âŠ•Â»(x, y)
    x + y
Â«k:endÂ»

Â«k:functionÂ» Â«f:fix2Â»(f, x)
    Â«k:returnÂ» Â«k:functionÂ»(y)
        f(x, y)
    Â«k:endÂ»
Â«k:endÂ»

Â«k:functionÂ» (foo::Â«t:FooÂ»)()
Â«k:endÂ»

Â«x:# ==============================Â»
Â«x:# short function definitionsÂ»
Â«x:# ==============================Â»

Â«f:sÂ»(n) = n + Â«c:1Â»

Base.Â«f:fooÂ»(x) = x

Â«f:Î¹Â»(n) = range(Â«c:1Â», n)

Â«f:âŠ—Â»(x, y) = x * y

(+)(x, y) = x + y

Â«x:# ==============================Â»
Â«x:# function definition parametersÂ»
Â«x:# ==============================Â»

Â«k:functionÂ» Â«f:fÂ»(x, y::Â«t:IntÂ», Â«:julia-ts-quoted-symbol-face:zÂ»=Â«c:1Â», ws...) Â«k:endÂ»

Â«k:functionÂ» (::Â«t:Type{Int}Â», x::Â«t:IntÂ» = Â«c:1Â», y::Â«t:IntÂ»...) Â«k:endÂ»

Â«k:functionÂ» Â«f:applyÂ»(f, args...; kwargs...)
Â«k:endÂ»

Â«k:functionÂ» Â«f:gÂ»(; x, y::Â«t:IntÂ», Â«:julia-ts-quoted-symbol-face:zÂ» = Â«c:1Â», kwargs...) Â«b:nothingÂ» Â«k:endÂ»

Â«x:# ==================================================Â»
Â«x:# function definition return typesÂ»
Â«x:# ==================================================Â»

Â«k:functionÂ» Â«f:sÂ»(n)::Â«t:MyIntÂ»
    MyInt(n + Â«c:1Â»)
Â«k:endÂ»

Â«k:functionÂ» Â«f:barÂ»(f, xs::Foo.Â«t:BarÂ»)::Foo.Â«t:BarÂ»
    map(f, xs)
Â«k:endÂ»

Â«x:# ==================================================Â»
Â«x:# function definition tuple parametersÂ»
Â«x:# ==================================================Â»

Â«k:functionÂ» Â«f:swapÂ»((x, y))
    (y, x)
Â«k:endÂ»

Â«k:functionÂ» Â«f:fÂ»((x, y)=(Â«c:1Â»,Â«c:2Â»))
    (x, y)
Â«k:endÂ»

Â«k:functionÂ» Â«f:carÂ»((x, y)::Â«t:TupleÂ»{Â«t:TÂ», Â«t:TÂ»}) Â«k:whereÂ» Â«t:TÂ»
    x
Â«k:endÂ»

Â«x:# ==================================================Â»
Â«x:# type parametric function definition parametersÂ»
Â«x:# ==================================================Â»

Â«k:functionÂ» Â«f:fÂ»(x::Â«t:TÂ») Â«k:whereÂ» Â«t:TÂ»
Â«k:endÂ»

Â«k:functionÂ» Â«f:fÂ»(n::Â«t:NÂ») Â«k:whereÂ» {Â«t:NÂ» <: Â«t:IntegerÂ»}
    n
Â«k:endÂ»

f(n::Â«t:NÂ», m::Â«t:MÂ») Â«k:whereÂ» {Â«t:NÂ» <: Â«t:NumberÂ»} Â«k:whereÂ» {Â«t:MÂ» <: Â«t:IntegerÂ»} = n^m

Â«t:FooÂ»{Â«t:TÂ»}(x::Â«t:TÂ») Â«k:whereÂ» {Â«t:TÂ»} = x

Â«k:functionÂ» Â«f:normÂ»(p::Â«t:PointÂ»{Â«t:TÂ»} Â«k:whereÂ» T<:Real)
    norm2(p)
Â«k:endÂ»

Base.Â«f:showÂ»(io::Â«t:IOÂ», ::Â«t:MIME"text/plain"Â», m::Â«t:MethodÂ»; kwargs...) = show_method(io, m, kwargs)

Â«x:# ==============================Â»
Â«x:# macro definitionsÂ»
Â«x:# ==============================Â»

Â«k:macroÂ» Â«f:nameÂ»(s::Â«t:SymbolÂ»)
    String(s)
Â«k:endÂ»

Â«k:macroÂ» Â«f:countÂ»(args...) length(args) Â«k:endÂ»

Â«x:# ==============================Â»
Â«x:# identifiersÂ»
Â«x:# ==============================Â»

abc_123_ABC
_fn!
Ï; Ï†; z
â„
xâ€²
Î¸Ì„
logyÌ‚
Ïµ
Å·
ğŸ™‹
ğŸ¦€

Â«x:# ==============================Â»
Â«x:# field expressionsÂ»
Â«x:# ==============================Â»

foo.x
bar.x.y.z

(a[Â«c:1Â»].b().c).d

Base.Â«:julia-ts-quoted-symbol-face::+Â»

df.Â«s:"a"Â»

Â«x:# ==============================Â»
Â«x:# index expressionsÂ»
Â«x:# ==============================Â»

a[Â«c:1Â», Â«c:2Â», Â«c:3Â»]
a[Â«c:1Â», :]
Â«s:"foo"Â»[Â«c:1Â»]

Â«x:# ==============================Â»
Â«x:# type parametrized expressionsÂ»
Â«x:# ==============================Â»

Â«t:VectorÂ»{Â«t:IntÂ»}
Â«t:VectorÂ»{<:Â«t:NumberÂ»}
Â«:julia-ts-interpolation-expression-face:$(Â»Â«D:usertypeÂ»Â«:julia-ts-interpolation-expression-face:)Â»{Â«t:TÂ»}

{Â«:julia-ts-quoted-symbol-face::xÂ»} ~ normal(Â«c:0Â», Â«c:1Â»)

Â«x:# ==============================Â»
Â«x:# function call expressionsÂ»
Â«x:# ==============================Â»

f()
g(Â«s:"hi"Â», Â«c:2Â»)
h(d...)

f(e; Â«:julia-ts-quoted-symbol-face:fÂ» = g)
g(arg; kwarg)

Â«k:newÂ»{typeof(xs)}(xs)

Â«x:# ========================================Â»
Â«x:# function call expressions with do blocksÂ»
Â«x:# ========================================Â»

reduce(xs) Â«k:doÂ» x, y
  f(x, y)
Â«k:endÂ»

Â«x:# ==============================Â»
Â«x:# macro call expressionsÂ»
Â«x:# ==============================Â»

Â«:julia-ts-macro-face:@assertÂ» x == y Â«s:"a message"Â»

Â«:julia-ts-macro-face:@testsetÂ» Â«s:"a"Â» Â«k:beginÂ»
  Â«v:bÂ» = c
Â«k:endÂ»

Â«:julia-ts-macro-face:@.Â» a * x + b

joinpath(Â«:julia-ts-macro-face:@__DIR__Â», Â«s:"grammar.js"Â»)

Â«:julia-ts-macro-face:@macroexpandÂ» Â«:julia-ts-macro-face:@asyncÂ» accept(socket)

Â«:julia-ts-macro-face:@Meta.dumpÂ» Â«c:1Â», Â«c:2Â»
Meta.Â«:julia-ts-macro-face:@dumpÂ» Â«v:xÂ» = Â«c:1Â»

Â«x:# ==============================Â»
Â«x:# closed macro call expressionsÂ»
Â«x:# ==============================Â»

Â«:julia-ts-macro-face:@enumÂ»(Light, red, yellow, green)
Â«f:fÂ»(Â«:julia-ts-macro-face:@nospecializeÂ»(x)) = x

Â«:julia-ts-macro-face:@mÂ»[Â«c:1Â», Â«c:2Â»] + Â«c:1Â»
Â«:julia-ts-macro-face:@mÂ» [Â«c:1Â», Â«c:2Â»] + Â«c:1Â»

Â«x:# ==============================Â»
Â«x:# quote expressionsÂ»
Â«x:# ==============================Â»

Â«:julia-ts-quoted-symbol-face::fooÂ»
Â«:julia-ts-quoted-symbol-face::constÂ»

Â«:julia-ts-quoted-symbol-face::(x; y)Â»
Â«:julia-ts-quoted-symbol-face::(x, y)Â»
Â«:julia-ts-quoted-symbol-face::[x, y, z]Â»

Â«:julia-ts-quoted-symbol-face::+Â»
Â«:julia-ts-quoted-symbol-face::->Â»
Â«:julia-ts-quoted-symbol-face::(::)Â»

Â«x:# ==============================Â»
Â«x:# interpolation expressionsÂ»
Â«x:# ==============================Â»

Â«:julia-ts-interpolation-expression-face:$Â»Â«D:fooÂ»
Â«:julia-ts-interpolation-expression-face:$Â»Â«D:objÂ».field
Â«:julia-ts-interpolation-expression-face:$(Â»Â«D:obj.fieldÂ»Â«:julia-ts-interpolation-expression-face:)Â»
Â«:julia-ts-interpolation-expression-face:$Â»Â«D:fÂ»(x)
Â«:julia-ts-interpolation-expression-face:$Â»Â«D:fÂ»[Â«c:1Â», Â«c:2Â»]
$Â«s:"foo"Â»

Â«k:usingÂ» Â«:julia-ts-interpolation-expression-face:$Â»Â«D:PackageÂ»: Â«:julia-ts-interpolation-expression-face:$(Â»Â«D:nameÂ»Â«:julia-ts-interpolation-expression-face:)Â»

Â«x:# Similar definitions in Gadfly/src/varset.jlÂ»
Â«k:mutableÂ» Â«k:structÂ» Â«:julia-ts-interpolation-expression-face:$(Â»Â«D:nameÂ»Â«:julia-ts-interpolation-expression-face:)Â»
  Â«:julia-ts-interpolation-expression-face:$(Â»Â«D:vars...Â»Â«:julia-ts-interpolation-expression-face:)Â»
Â«k:endÂ»
Â«k:functionÂ» Â«:julia-ts-interpolation-expression-face:$(Â»Â«D:nameÂ»Â«:julia-ts-interpolation-expression-face:)Â»(Â«:julia-ts-interpolation-expression-face:$(Â»Â«D:parameters_exprÂ»Â«:julia-ts-interpolation-expression-face:)Â»)
    Â«:julia-ts-interpolation-expression-face:$(Â»Â«D:nameÂ»Â«:julia-ts-interpolation-expression-face:)Â»(Â«:julia-ts-interpolation-expression-face:$(Â»Â«D:parsed_vars...Â»Â«:julia-ts-interpolation-expression-face:)Â»)
Â«k:endÂ»

Â«x:# ==============================Â»
Â«x:# adjoint expressionsÂ»
Â«x:# ==============================Â»

[u, v]'
A'[i]
(x, y)'
f'(x)
Â«:julia-ts-quoted-symbol-face::aÂ»'

Â«x:# ==============================Â»
Â«x:# juxtaposition expressionsÂ»
Â«x:# ==============================Â»

Â«c:1Â»x
Â«c:2Â»v[i]
Â«c:3Â»f(x)
Â«c:4Â»df.a
Â«c:5Â»Â«s:u"kg"Â»
x'x
Â«c:2Â»x^Â«c:2Â» - Â«c:.3Â»x
Â«c:2Â»(x-Â«c:1Â»)^Â«c:2Â» - Â«c:3Â»(x-Â«c:1Â»)

Â«x:# =============================Â»
Â«x:# arrow function expressionsÂ»
Â«x:# =============================Â»

x -> x^Â«c:2Â»
(x,y,z)-> Â«c:2Â»*x + y - z
()->Â«c:3Â»
() -> (sleep(Â«c:0.1Â»); i += Â«c:1Â»; l)
a -> Â«v:aÂ» = Â«c:2Â», Â«c:3Â»

Â«x:# ==============================Â»
Â«x:# boolean literalsÂ»
Â«x:# ==============================Â»

Â«c:trueÂ»
Â«c:falseÂ»

Â«x:# ==============================Â»
Â«x:# integer number literalsÂ»
Â«x:# ==============================Â»

Â«c:0b01Â»
Â«c:0o01234567Â»
Â«c:0123456789Â»
Â«c:123_456_789Â»
Â«c:0x0123456789_abcdef_ABCDEFÂ»

Â«x:# ==============================Â»
Â«x:# float number literalsÂ»
Â«x:# ==============================Â»

Â«c:0123456789.Â»
Â«c:.0123456789Â»
Â«c:0123456789.0123456789Â»

Â«c:9e10Â»
Â«c:9E-1Â»
Â«c:9f10Â»
Â«c:9f-1Â»

Â«c:.1e10Â»
Â«c:1.1e10Â»
Â«c:1.e10Â»

Â«c:0x0123456789_abcdef.ABCDEFp0Â»
Â«c:0x0123456789_abcdef_ABCDEF.p-1Â»
Â«c:0x.0123456789_abcdef_ABCDEFp1Â»

Â«x:# ==============================Â»
Â«x:# character literalsÂ»
Â«x:# ==============================Â»

Â«c:' 'Â»
Â«c:'o'Â»
Â«c:'\t'Â»
Â«c:'\uffff'Â»
Â«c:'\U10ffff'Â»

Â«x:# ==============================Â»
Â«x:# string literalsÂ»
Â«x:# ==============================Â»

Â«s:""Â»
Â«s:"\""Â»
Â«s:"foo
 bar"Â»
Â«s:"this is a \"string\"."Â»
Â«s:"""this is also a "string"."""Â»
Â«v:bandÂ» = Â«s:"Interpol"Â»
Â«s:"Â»Â«:julia-ts-string-interpolation-face:$Â»Â«D:bandÂ»Â«s: is a cool band"Â»
Â«s:"Â»Â«:julia-ts-string-interpolation-face:$(Â»Â«c:2Â»Â«D:Ï€Â»Â«:julia-ts-string-interpolation-face:)Â»Â«s: is a cool number"Â»
Â«s:"cells interlinked within Â»Â«:julia-ts-string-interpolation-face:$(Â»Â«D:"cells interlinked whithin Â»Â«:julia-ts-string-interpolation-face:$(Â»Â«D:"cells interlinked whithin one stem"Â»Â«:julia-ts-string-interpolation-face:)Â»Â«D:"Â»Â«:julia-ts-string-interpolation-face:)Â»Â«s:"Â»

Â«x:# ==============================Â»
Â«x:# command string literalsÂ»
Â«x:# ==============================Â»

Â«s:`pwd`Â»
Â«s:m`pwd`Â»
Â«s:`cd Â»Â«:julia-ts-string-interpolation-face:$Â»Â«D:dirÂ»Â«s:`Â»
Â«s:`echo \`cmd\``Â»
Â«s:```
echo "\033[31mred\033[m"
```Â»

Â«x:# ==============================Â»
Â«x:# non-standard string literalsÂ»
Â«x:# ==============================Â»

Â«x:# FIXME: \s shouldn't be an escape_sequence hereÂ»
Â«v:trailing_wsÂ» = Â«s:r"\s+$"Â»
Â«v:versionÂ» = Â«s:v"1.0"Â»
Â«s:K"\\"Â»

Â«x:# ==============================Â»
Â«x:# commentsÂ»
Â«x:# ==============================Â»

Â«x:# commentÂ»
Â«x:#= comment =#Â»
Â«x:#=
comment
=#Â»
Â«v:xÂ» = Â«x:#= comment =#Â» Â«c:1Â»

Â«x:#=
nested #= comments =# =#Â»
Â«x:#==#Â»

Â«x:# ==============================Â»
Â«x:# assignment operatorsÂ»
Â«x:# ==============================Â»

Â«v:aÂ» = b
a .. b = a * b
Â«v:tupÂ» = Â«c:1Â», Â«c:2Â», Â«c:3Â»
Â«v:carÂ», cdr... = list
c &= d Ã·= e

Â«x:# ==============================Â»
Â«x:# binary arithmetic operatorsÂ»
Â«x:# ==============================Â»

a + b
a ++ Â«c:1Â» Ã— b â¥Œ Â«c:2Â» â†’ c
a // b
Â«v:xÂ» = A \ (v Ã— w)

Â«x:# ==============================Â»
Â«x:# other binary operatorsÂ»
Â«x:# ==============================Â»

a & b | c
(x >>> Â«c:16Â», x >>> Â«c:8Â», x) .& Â«c:0xffÂ»

Dict(b => c, d => e)

x |>
  f |>
  g

Â«c:1Â»..Â«c:10Â»
(Â«c:1Â»:Â«c:10Â»...,)

Â«x:# ==============================Â»
Â«x:# binary comparison operatorsÂ»
Â«x:# ==============================Â»

a === Â«c:1Â»
a! != Â«c:0Â»

A âŠ† B âŠ† C
x â‰¥ Â«c:0Â» â‰¥ z

Â«x:# ==============================Â»
Â«x:# unary operatorsÂ»
Â«x:# ==============================Â»

-A'
+a
-b
âˆšÂ«c:9Â»
!p === !(p)
Â«c:1Â» ++ +Â«c:2Â»

Â«x:# =============================Â»
Â«x:# operator broadcastingÂ»
Â«x:# =============================Â»

a .* b .+ c
.~[x]

Â«x:# ==============================Â»
Â«x:# ternary operatorÂ»
Â«x:# ==============================Â»

Â«v:xÂ» = batch_size == Â«c:1Â» ?
  rand(Â«c:10Â») :
  rand(Â«c:10Â», batch_size)

Â«x:# ==============================Â»
Â«x:# operators as valuesÂ»
Â«x:# ==============================Â»

Â«v:xÂ» = +
âª¯ = .â‰¤
print(:)
foo(^, Ã·, -)

Â«x:# ==============================Â»
Â«x:# compound statementsÂ»
Â«x:# ==============================Â»

Â«k:beginÂ»
Â«k:endÂ»

Â«k:beginÂ»
    foo
    bar
    baz
Â«k:endÂ»

Â«x:# ==============================Â»
Â«x:# quote statementsÂ»
Â«x:# ==============================Â»

Â«k:quoteÂ» Â«k:endÂ»

Â«k:quoteÂ»
  Â«v:xÂ» = Â«c:1Â»
  Â«v:yÂ» = Â«c:2Â»
  x + y
Â«k:endÂ»

Â«x:# ==============================Â»
Â«x:# let statementsÂ»
Â«x:# ==============================Â»

Â«k:letÂ»
Â«k:endÂ»

Â«k:letÂ» Â«v:var1Â» = value1, Â«v:var2Â», Â«v:var3Â» = value3
    code
Â«k:endÂ»

Â«x:# ==============================Â»
Â«x:# if statementsÂ»
Â«x:# ==============================Â»

Â«k:ifÂ» a
Â«k:elseifÂ» b
Â«k:elseÂ»
Â«k:endÂ»

Â«k:ifÂ» Â«c:trueÂ» Â«c:1Â» Â«k:elseÂ» Â«c:0Â» Â«k:endÂ»

Â«k:ifÂ» a
  b()
Â«k:elseifÂ» c
  d()
  d()
Â«k:elseÂ»
  e()
Â«k:endÂ»

Â«x:# ==============================Â»
Â«x:# try statementsÂ»
Â«x:# ==============================Â»

Â«k:tryÂ» Â«k:catchÂ» Â«k:endÂ»
Â«k:tryÂ» Â«k:finallyÂ» Â«k:endÂ»

Â«k:tryÂ»
    sqrt(x)
Â«k:catchÂ»
    sqrt(complex(x, Â«c:0Â»))
Â«k:endÂ»

Â«k:tryÂ»
    operate_on_file(f)
Â«k:finallyÂ»
    close(f)
Â«k:endÂ»

Â«k:tryÂ»
    Â«x:# fallibleÂ»
Â«k:catchÂ»
    Â«x:# handle errorsÂ»
Â«k:elseÂ»
    Â«x:# do something if there were no exceptionsÂ»
Â«k:endÂ»

Â«x:# ==============================Â»
Â«x:# for statementsÂ»
Â«x:# ==============================Â»

Â«k:forÂ» x Â«k:inÂ» xs Â«k:endÂ»

Â«k:forÂ» x Â«k:inÂ» xs foo!(x) Â«k:endÂ»

Â«k:forÂ» i Â«k:inÂ» [Â«c:1Â», Â«c:2Â», Â«c:3Â»]
  print(i)
Â«k:endÂ»

Â«k:forÂ» (a, b) Â«k:inÂ» c
  print(a, b)
Â«k:endÂ»

Â«x:# ==============================Â»
Â«x:# for outer statementsÂ»
Â«x:# ==============================Â»

Â«v:nÂ» = Â«c:1Â»
Â«k:forÂ» Â«k:outerÂ» n Â«k:inÂ» range
  body
Â«k:endÂ»

Â«k:forÂ» Â«k:outerÂ» x = iter1, Â«k:outerÂ» y = iter2
  body
Â«k:endÂ»

Â«x:# ==============================Â»
Â«x:# while statementsÂ»
Â«x:# ==============================Â»

Â«k:whileÂ» Â«c:trueÂ» Â«k:endÂ»

Â«k:whileÂ» i < Â«c:5Â»
  print(i)
  Â«k:continueÂ»
  Â«k:breakÂ»
Â«k:endÂ»

Â«k:whileÂ» a(); b(); Â«k:endÂ»

Â«x:# ==============================Â»
Â«x:# return statementsÂ»
Â«x:# ==============================Â»

Â«k:returnÂ»
Â«k:returnÂ» a
Â«k:returnÂ» a || b
Â«k:returnÂ» a, b, c

Â«x:# ==============================Â»
Â«x:# export statementsÂ»
Â«x:# ==============================Â»

Â«k:exportÂ» a
Â«k:exportÂ» a, b, +, (*)
Â«k:exportÂ» Â«:julia-ts-macro-face:@macroMcAtfaceÂ»
Â«k:publicÂ» a
Â«k:publicÂ» a, b, +, (*)
Â«k:publicÂ» Â«:julia-ts-macro-face:@macroMcAtfaceÂ»

Â«x:# ==============================Â»
Â«x:# import statementsÂ»
Â«x:# ==============================Â»

Â«k:importÂ» Pkg

Â«k:usingÂ» Sockets

Â«k:usingÂ» ..Foo, ..Bar

Â«k:importÂ» CSV, Chain, DataFrames

Â«k:importÂ» Base: show, Â«:julia-ts-macro-face:@kwdefÂ», +, (*)

Â«k:importÂ» LinearAlgebra as la

Â«k:importÂ» Base: Â«:julia-ts-macro-face:@viewÂ» as Â«:julia-ts-macro-face:@vÂ»

Â«x:# ===============================Â»
Â«x:# const statementsÂ»
Â«x:# ===============================Â»

Â«k:constÂ» Â«v:xÂ» = Â«c:5Â»
Â«k:constÂ» Â«v:yÂ», Â«v:zÂ» = Â«c:1Â», Â«c:2Â»

(Â«c:0Â», Â«k:constÂ» Â«v:xÂ», Â«v:yÂ» = Â«c:1Â», Â«c:2Â»)

Â«x:# ===============================Â»
Â«x:# local statementsÂ»
Â«x:# ===============================Â»

Â«k:localÂ» Â«v:xÂ»
Â«k:localÂ» Â«v:yÂ», Â«v:zÂ» = Â«c:1Â», Â«c:2Â»
Â«k:localÂ» Â«f:fooÂ»() = Â«c:3Â»
Â«k:localÂ» Â«k:functionÂ» Â«f:barÂ»() Â«c:4Â» Â«k:endÂ»

Â«x:# ===============================Â»
Â«x:# global statementsÂ»
Â«x:# ===============================Â»

Â«k:globalÂ» Â«v:XÂ»
Â«k:globalÂ» Â«v:YÂ», Â«v:ZÂ» = Â«c:11Â», Â«c:42Â»
Â«k:globalÂ» Â«f:fooÂ»() = Â«c:3Â»
Â«k:globalÂ» Â«k:functionÂ» Â«f:barÂ»() Â«c:4Â» Â«k:endÂ»
